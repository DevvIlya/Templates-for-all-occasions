Для запуска проекта необходимо:

Установить зависимости:
    pip install -r requirements.txt

Провести миграцию:
    python manage.py migrate

Загрузить тестовые данные:
    python manage.py loaddata articles.json

Запустить отладочный веб-сервер проекта:
    python manage.py runserver


DB_NAME=postgres
POSTGRES_DB=postgres
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
DB_HOST=db
DB_PORT=5432
SECRET_KEY=mysecretkey
ALLOWED_HOSTS=158.160.76.223
DEBUG = False


sudo chmod ugo+rwx foodgram

python -m pip install --upgrade pip

pip install django-colorfield
pip install django-import-export
pip install djangorestframework

pip install django-filters
pip install django-filter==2.4.0
pip install djoser


pip install python-dotenv
pip install Django==3.2
pip install psycopg2-binary



Как победить любую ошибку 
⚔️


Три действия, которые нужно проделать перед тем, как задать вопрос в Пачке:


1. Прочитать ошибку
Обычно она бросается в глаза. В трейсбэке ошибка в самом низу. В веб-интерфейсе Джанго она вверху. Иногда стоит почитать и остальные странные надписи.


2. Перевести её
Там же на английском почему-то. Если вам сходу непонятно, что написано, можно воспользоваться переводчиком (хотя обычно понятно). Без этого никак. Чтобы что-то поправить, надо же понимать, что не так, правда?


3. Загуглить ошибку
Это прям ежедневная работа программиста. На самом деле, будет не особо сильным преувеличением, что мы тут учим вас гуглить. Часто это вызывает даже некоторое непонимание "я задал вопрос, а меня отправили гуглить! Я пришел, чтоб меня учили, а не в гугл отправляли". Но навык ходить в поисковик за любым вопросом сложно переоценить. Вводить в поисковике правильный запрос, читать треды на StackOverflow – от этого тоже никуда не деться. 


—————————


Кажется, уже сотни раз в ответ на вопрос "у меня что-то сломалось" со скриншотом я задавал встречный вопрос "а что в ошибке-то написано? )". И часто всё заканчивалось еще на пункте 2 – когда ошибка была переведена)


Этот пост призван облегчить работу и вам, и мне) Буду регулярно к нему отсылать




Почему мы учим какую-то древнюю версию Джанги ваще?! И сложно ли перейти на другую?

Переход в учебном плане не составляет какой-то проблемы. Как говорит @khmaker, "То что вам дается в рамках учебного курса практически не зависит от версии" 
Если ты после курса придешь работать в проект, где 4.1 – особой разницы не заметишь на фоне всех новшеств первой работы)
А если речь про то, чтобы перевести готовый проект с 2.2 на 4.1 то это вполне себе задача) Чем больше проект, тем больше проблема. Нужен прям сильный аргумент для того, чтобы переползать (обычно это угроза прекращения поддержки текущих зависимостей или новые важные фичи новой версии, который очень нужны). 

Именно поэтому мы в курсе до сих пор на 2.2. Особых профитов этот переход не приносит, а мигрировать уже весьма трудоемко – проект большой.




в чем смысл создания своих собственных классов исключений?
Допустим у меня в функции отправки сообщений возникает исключение telegram.error.TelegramError, почему я не могу рейзить его? — справедливо спрашивает Анна. 

Отвечаю:
Тут общая логика такая: 
Исключения библиотеки Телеграма предназначены для клиента этой библиотеки – то есть, разработчика. Это один из способов общения разработчика библиотеки с пользователем библиотеки.

Мы, когда ловим такое исключение, хотим взять от него только то, что нам надо. А ненужное не брать. Самый простой и понятный способ – поймать его, как-то приготовить, и выкинуть своё (или не выкинуть, а, скажем, залогировать).

Можно было бы, конечно, и телеграмовское оставить, нас бы никто не съел (ну, кроме ревьюера), но это считается плохим стилем. В данном случае это не особо страшно, ведь клиент нашего исключения – мы сами – мы для себя его кастомизируем.  Но  это же, скорее, редкость)
Да и странно было бы учить вас плохим практикам)





Какие порты, чего, куда и зачем перенаправляют?


А вообще, суть такая: весь веб работает по 80-му порту (протокол http) или 443 (https). Оба варианта слушает внешний nginx. Внешний nginx живет не в контейнере. Он перенаправляет запросы в нашу сеть контейнеров (фронт, бэк, gateway, база) – с 80-го порта все запросы пересылает на локалхост, например, 9000-й порт. 

Из всей сети контейнеров его может услышать только gateway, он же "внутренний nginx" – живет в контейнере, но умеет смотреть во внешний мир и принимать запросы от внешнего nginx, потому, что в докер-компоусе мы написали вот так:

gateway:
    build: ./nginx/ 
    ports:
        - 9000:80
Это значит, что конкретно этот контейнер gateway создастся с "проброшенными портами". Все запросы по 9000-му порту он будет перенаправлять на 80-й, но уже по внутренней сети контейнеров.


А потом мы уже для внутреннего nginx  пишем конфиг, который раскидывает запросы, пришедшие от внешнего nginx по контейнерам. Например, вот таким куском конфига внешнего nginx:

server {
  listen 80;
  index index.html;


  location / {
    proxy_set_header Host $http_host;
    proxy_pass http://127.0.0.1:9000;
  }
мы говорим внешнему nginx – собери-ка все, что получил по 80-му порту и перенаправь в на эту же самую машину по 9000-му порту. А там кто-нибудь найдется, подберет и разберется. 


А потом мы уже для внутреннего nginx пишем конфиг, который раскидывает запросы, пришедшие от внешнего nginx, по контейнерам. Например, вот таким куском конфига внутреннего nginx (который, напомню, внутри контейнера живет):

server {
  listen 80;
  index index.html;

  location /api/ {
    proxy_set_header Host $http_host;
    proxy_pass http://backend:8000/api/;
  }
 Мы говорим внутреннему nginx – собери-ка все, что получил по 80-му порту и урлу, начинающемся на /api и перенаправь в контейнер backend внутри своей сети на 8000-й порт.


Спрашивается, как же так получилось, что внутренний nginx тоже слушает 80-й порт? Ведь мы трафик снаружи внешним nginx перенаправляем с 80-го на 9000-й? Но тут мы вспоминаем, что сам внутренний nginx живет внутри контейнера. А в контейнере открыта только входная дверка № 9000. А выходная № 80. 


Поэтому получается такой путь:
внешний трафик (от пользователя, из браузера) приходит на 80-й порт внешнего nginx, перенаправляется им внутри того же сервера на другой порт 9000. На этом порту его получает контейнер gateway и снова переправляет, но уже внутри закрытой сети контейнеров - и снова на 80-й порт. (сама закрытая сеть создалась неявно при docker compose up - и туда попали все контейнеры, упомянуты в докер-компоус файлике). А уже внутренний nginx из контейнера gateway принимает траффик от контейнера по 80-му порту и раскидывает разный траффик по разным контейнерам внутри сети. Например, контейнеру backend он достается по 8000-му порту, если url запроса начинается с /api.
 
А как же сервер определяет нужную сеть контейнеров, у меня же 2 приложения на сервере должно быть на момент 15 спринта (таски и китти)? Как он определяет по какому порту подключиться к нужной сети контейнеров. Где мы это прописываем? – спрашивает нас Армен.

А как-то так: вторую сеть мы держим на другом порту, например, на 8080. И внешним nginx пересылаем траффик с одного урла на один порт(9000), с другой урла на другой(7000).

Дока докер-компоуса про порты и прочие сетевые штуки
Доку nginx надо гуглить на предмет каждой директивы отдельно (proxy_pass, try_files,  и т.п.)


Вот небольшое видео https://youtu.be/4m40a5uFROA о том как создать ssh-ключ в любой доступной директории и потом пользоваться этим ключом из этой директории.
В описании небольшие пояснения к некоторым командам.

Как мне что-то стороннее (например, какой-то пример из теории) попробовать поковырять в питончике и не сломать проект


1. Создаешь новую папку, никак не связанную с проектом спринта. Не внутри.
2. Деактивируешь старое окружение.
3. Создаешь новое.
4. Активируешь новое. Тут можно устанавливать-удалять библиотеки, они никому не помешают.
5. Создаешь там временный файлик. Например, test.py Временный значит – любой.
6. В нем делаешь любые эксперименты.
7. Закончив эксперименты, можно возвращаться к проекту. Но важно не забыть деактивировать экспериментальное окружение и активировать окружение, которое использовалось при разработке проекта.

Любая задача "попробовать что-то" решается по этому алгоритму.




Про массивы и списки

То в питоне то, что во всяких Си и Паскалях до того называлось "массив" (array) обозвали list. Что в переводе "список". 
Правильно утверждать, что list в Питоне – это массив. Если еще точнее, то "динамический массив". Динамический потому, что при создании выделяет себе сколько-то памяти, а потом может расширяться, если добавить больше элементов, чем изначально выделено памяти.
Отдельно стоит упомянуть про структуру данных – список – полное название которой  "связный список" (linked list). Это вообще не про то и с нашими массивами-списками вещь никак не связанная, простите за каламбур.




Шпаргалка по настройке сервера в рамках 14го спринта.
Чтобы не пришлось бегать по тредам решил собрать основное на мой взгляд в один тред.


Часто могут возникать проблемы с ошибками 400, 500, 502 которые сложно поправить.
В первую очередь предлагаю перегрузить nginx и gunicorn. Так же важно запоминать действия, чтобы если возникнет ошибка, было понятно куда смотреть и где править.Старайтесь быть последовательными. Замечено, что при настройке инфраструктуры, суматошные панические попытки что-то починить, только усугубляют ситуацию и еще больше запутывают.  


Если после настройки nginx не работает фронт, то:
- Cледует убедиться, что файлы фронта лежат в указанной в параметре root директории 
- Правильно указан путь до файлов, не забыли про / в начале пути.


Если не работает бекенд:
- Проставьте DUBUG=True в первую очередь, так будет проще увидеть проблему.
- Так же можете временно выключить файрвол, чтобы на прямую по порту сходить в бекенд:
    - sudo ufw disable.  (После того как решите проблему с бекендом, не забудьте обратно включить sudo ufw enable. Так же можно разрешить нужный порт в ufw)
    - Теперь можно обратиться на прямую в бекенд по ip:port - домен тут не подходит, так как им заведует nginx, а мы хотим напрямую сходить.


502 ошибка - означает что nginx не может перенаправить запрос на бекенд
- Смотрим в конфигурацию nginx, нет ли ошибки в location для бекенда
- Нужно убедиться что бекенд запущен, возможно сервис отказывается запускаться


Бекенд по ходу теории запускается тремя разными способами:
- Через python manage.py runserver (тестовый запуск, так как это тестовый сервер в продет такой запуск нельзя оставлять)
- Через gunicorn (так запускаем настоящий боевой сервер под прод)
- Через service запускается gunicorn (тут мы запускаем тот же gunicorn, только переводим его запуск под контроль systemctl. Итоговым должен быть такой запуск)


Если один из этих способов включён, то он займет порт и не будет пускать другой запуск потому же порту. Для того чтобы запустить другим способом, нужно остановить предыдущий запуск.
Nginx может работать с любым из этих запусков. Если есть проблемы с бекендом, чтобы видеть запросы в консоли можете выключить сервис gunicorn и включить Python manage.py runserver. 


400 ошибка говорит об ошибке с запросом, обычно это ошибка с ALLOWED_HOSTS. Чтобы локализовать можно временно включить дебаг режим либо прописать доступ для всех хостов ALLOWED_HOSTS = [«*»]


500 ошибка обычно означает падение бекенда, локализовать проблему будет легче при включенном дебаг режиме и запуске бекенда через manage.py.


Инструкция location / - должна быть после location /admin/ location /api/ и location для sentry. Иначе все запросы будет ловить location /. То есть порядок тут важен.


